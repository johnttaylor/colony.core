<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Colony.Core: Cpl::Text Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo2.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Colony.Core
   </div>
   <div id="projectbrief">Embedded C++ Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_cpl_1_1_text.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cpl::Text Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> 
<pre>    

The Text namespace provides yet-another String class and additional string
and/or text processing utilities.  What makes the Cpl::Text::String
classes different from other String classes is that it supports a ZERO
dynamic memory allocation interface and implementation.  There is also
a dyanmic memory implementation of the String interface for when strict
memory management is not required.

</pre>    
 </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_f_string.html">DFString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_f_string_item.html">DFStringItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_string.html">DString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_string_item.html">DStringItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string.html">FString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string_item.html">FStringItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string.html">String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string_item.html">StringItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7023b131150bf6e746c6eae38daf4294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294">a2i</a> (int &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="separator:a7023b131150bf6e746c6eae38daf4294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545e025ede3938fd5e326ea84a8d846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a5545e025ede3938fd5e326ea84a8d846">a2ui</a> (unsigned &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="separator:a5545e025ede3938fd5e326ea84a8d846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb577681a19f3b6562acd0c3eb7095b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#afb577681a19f3b6562acd0c3eb7095b4">a2l</a> (long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="separator:afb577681a19f3b6562acd0c3eb7095b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c830e654edfb12fac73cd26dcadfd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a06c830e654edfb12fac73cd26dcadfd7">a2ul</a> (unsigned long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="separator:a06c830e654edfb12fac73cd26dcadfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4912f3974cf06ae6e39c336473a81f3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a4912f3974cf06ae6e39c336473a81f3c">a2ll</a> (long long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="separator:a4912f3974cf06ae6e39c336473a81f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c51a67b6587ebfafe35ea064075d828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a0c51a67b6587ebfafe35ea064075d828">a2ull</a> (unsigned long long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="separator:a0c51a67b6587ebfafe35ea064075d828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926efe9ed5a7d87873a82fd377872d8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a926efe9ed5a7d87873a82fd377872d8d">a2d</a> (double &amp;convertedValue, const char *string, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="separator:a926efe9ed5a7d87873a82fd377872d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ae1c0d2f2152fd16d950b7a44a3b7b1bd">a2b</a> (bool &amp;convertedValue, const char *string, const char *trueToken=&quot;T&quot;, const char *falseToken=&quot;F&quot;, const char **endptr=0)</td></tr>
<tr class="separator:ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47ee4c26d7715d51aeb9d44dcb41eb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ab47ee4c26d7715d51aeb9d44dcb41eb7">asciiHexToBuffer</a> (void *dstBinary, const char *srcString, size_t dstMaxLen)</td></tr>
<tr class="separator:ab47ee4c26d7715d51aeb9d44dcb41eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e078e798506c61e2d5a48b54590b059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a8e078e798506c61e2d5a48b54590b059">bufferToString</a> (const void *buffer, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">String</a> &amp;destString, bool appendToString=false)</td></tr>
<tr class="separator:a8e078e798506c61e2d5a48b54590b059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa239bc40f360df352df10227259e5597"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#aa239bc40f360df352df10227259e5597">bufferToAsciiHex</a> (const void *binaryData, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">String</a> &amp;destString, bool upperCase=true, bool appendToString=false)</td></tr>
<tr class="separator:aa239bc40f360df352df10227259e5597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ac81a7c3db0fdf1ece0a09bdb73ef8e9c">formatMsecTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, unsigned long long timeStampInMsecs, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="separator:ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab519c3ecf8ad77149f44dc41ef73f843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ab519c3ecf8ad77149f44dc41ef73f843">formatSecTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, unsigned long long timeStampInSecs, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="separator:ab519c3ecf8ad77149f44dc41ef73f843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed7b1983a755086b0ef532731c0273e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a8ed7b1983a755086b0ef532731c0273e">formatPrecisionTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, <a class="el" href="class_cpl_1_1_system_1_1_elasped_time.html#add7a15236f91f615d03a1fae31d86a42">Cpl::System::ElaspedTime::Precision_T</a> timeStamp, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="separator:a8ed7b1983a755086b0ef532731c0273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e61c7a26d37010bdfe93ade5b59ba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba">stripSpace</a> (const char *s)</td></tr>
<tr class="separator:ac14e61c7a26d37010bdfe93ade5b59ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42c55345a21ef44d3d0f05b6db6f8ec"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec">stripNotSpace</a> (const char *s)</td></tr>
<tr class="separator:ad42c55345a21ef44d3d0f05b6db6f8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a9a7fd5c7962fc037dd8ab9fd51355"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a08a9a7fd5c7962fc037dd8ab9fd51355">stripTrailingSpace</a> (const char *s)</td></tr>
<tr class="separator:a08a9a7fd5c7962fc037dd8ab9fd51355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cb01066ac4701cb10670ee4325e44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#af1cb01066ac4701cb10670ee4325e44b">removeTrailingSpace</a> (char *s)</td></tr>
<tr class="separator:af1cb01066ac4701cb10670ee4325e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb3cd13b0126b677c9dce381cfc09a0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#aaeb3cd13b0126b677c9dce381cfc09a0">stripChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="separator:aaeb3cd13b0126b677c9dce381cfc09a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5854e604efe16644059855ce4a8a9e04"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a5854e604efe16644059855ce4a8a9e04">stripNotChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="separator:a5854e604efe16644059855ce4a8a9e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7480520348029f1b992f6fbef338010d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a7480520348029f1b992f6fbef338010d">stripTrailingChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="separator:a7480520348029f1b992f6fbef338010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9a2f33932dfaa319c5eb23b36fe8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#aae9a2f33932dfaa319c5eb23b36fe8de">removeTrailingChars</a> (char *s, const char *charsSet)</td></tr>
<tr class="separator:aae9a2f33932dfaa319c5eb23b36fe8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae1c0d2f2152fd16d950b7a44a3b7b1bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2b </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>trueToken</em> = <code>&quot;T&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>falseToken</em> = <code>&quot;F&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method convert the specified string to an boolean. The method returns true if the converstion was succesfful. If the first N characters of 'string' match the specified boolean token - the conversion is consider succesfull (i.e. there is no required seperator/terminator character for a boolean token). If endptr is specified, a pointer to the first character 'after' the boolean token is returned. </p>

</div>
</div>
<a class="anchor" id="a926efe9ed5a7d87873a82fd377872d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2d </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the specified string to an double. The method returns true if the conversion was successful. By default the conversion assumes that the 'end-of-number' is end-of-string. If endptr is specified, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a class="anchor" id="a7023b131150bf6e746c6eae38daf4294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2i </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the specified string to an integer. The method returns true if the conversion was successful. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a class="anchor" id="afb577681a19f3b6562acd0c3eb7095b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2l </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the specified string to an long. The method return true if the conversion was successful. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a class="anchor" id="a4912f3974cf06ae6e39c336473a81f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ll </td>
          <td>(</td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the specified string to a long long. The method return true if the conversion was successful. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a class="anchor" id="a5545e025ede3938fd5e326ea84a8d846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ui </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the specified string to an unsigned integer. The method returns true if the conversion was successful. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a class="anchor" id="a06c830e654edfb12fac73cd26dcadfd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ul </td>
          <td>(</td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the specified string to an unsigned long. The method returns true if the conversion was successful. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a class="anchor" id="a0c51a67b6587ebfafe35ea064075d828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ull </td>
          <td>(</td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the specified string to an unsigned long long. The method returns true if the conversion was successful. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a class="anchor" id="ab47ee4c26d7715d51aeb9d44dcb41eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::asciiHexToBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstBinary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method will convert an 'ASCII HEX' string to an equalivent binary buffer, i.e. the reverse of <a class="el" href="namespace_cpl_1_1_text.html#aa239bc40f360df352df10227259e5597">bufferToAsciiHex()</a> in <a class="el" href="format_8h.html">format.h</a>. If the entire string was not able to be converted then false is returned, else true is returned. </p>

</div>
</div>
<a class="anchor" id="aa239bc40f360df352df10227259e5597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToAsciiHex </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>binaryData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String &amp;&#160;</td>
          <td class="paramname"><em>destString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upperCase</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method will convert a binary buffer to 'ASCII HEX', e.g. given the binary data of { 12, F2, 54 }, destString:= "12F254". The method will return if buffer was succesfully converted, i.e. the ENTIRE buffer was converted to a string; else false is returned (this include the cases of null 'buffer' pointer, 'len' equals zero, or not enough memory in 'destString' to contain the final result).</p>
<p>Note: The default operation is to use uppercase text and to clear the destString before the conversion. </p>

</div>
</div>
<a class="anchor" id="a8e078e798506c61e2d5a48b54590b059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String &amp;&#160;</td>
          <td class="paramname"><em>destString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method will take a raw data buffer and convert it to an 'viewable' string. Non-printable values will displayed as '.'. Note: The default operation is to clear the destString before the conversion. The method will return if buffer was succesfully converted, i.e. the ENTIRE buffer was converted; else false is returned (this include the cases of null 'buffer' pointer, 'len' equals zero, or not enough memory in 'destString' to contain the final result). </p>

</div>
</div>
<a class="anchor" id="ac81a7c3db0fdf1ece0a09bdb73ef8e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatMsecTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>timeStampInMsecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encodeDay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the binary milliseoond count of 'timeStampInMsecs' to a string with the folloing format: "DD HH:MM:SS.SSS". The converted result is returned via 'buffer'. If the results where trunaced by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a class="anchor" id="a8ed7b1983a755086b0ef532731c0273e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatPrecisionTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_system_1_1_elasped_time.html#add7a15236f91f615d03a1fae31d86a42">Cpl::System::ElaspedTime::Precision_T</a>&#160;</td>
          <td class="paramname"><em>timeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encodeDay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the <a class="el" href="class_cpl_1_1_system_1_1_elasped_time.html#add7a15236f91f615d03a1fae31d86a42" title="Datatype for time in seconds with a &#39;fractional&#39; millisecond precision. ">Cpl::System::ElaspedTime::Precision_T</a> value of time into a string with the folloing format: "DD HH:MM:SS.SSS". The converted result is returned via 'buffer'. If the results where trunaced by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a class="anchor" id="ab519c3ecf8ad77149f44dc41ef73f843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatSecTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>timeStampInSecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encodeDay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method converts the binary second count of 'timeStampInSecs' to a string with the folloing format: "DD HH:MM:SS". The converted result is returned via 'buffer'. If the results where trunaced by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a class="anchor" id="aae9a2f33932dfaa319c5eb23b36fe8de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Text::removeTrailingChars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as removeTrailingSpaces(), except the specified characters set is used for "whitespace" any trailing white space.</p>
<p>NOTE: If 's' OR 'charsSet' is null, then nothing is done. </p>

</div>
</div>
<a class="anchor" id="af1cb01066ac4701cb10670ee4325e44b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Text::removeTrailingSpace </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method TRUNCATES the specified null-terminated string by eliminating any trailing white space.</p>
<p>NOTE: If 's' is null, then nothing is done. </p>

</div>
</div>
<a class="anchor" id="aaeb3cd13b0126b677c9dce381cfc09a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba">stripSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters.</p>
<p>NOTES: </p>
<pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.</pre> 
</div>
</div>
<a class="anchor" id="a5854e604efe16644059855ce4a8a9e04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripNotChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec">stripNotSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters.</p>
<p>NOTES: </p>
<pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.</pre> 
</div>
</div>
<a class="anchor" id="ad42c55345a21ef44d3d0f05b6db6f8ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripNotSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a pointer to the FIRST whitespace character in the the specified null-terminated string. NOTES: </p>
<pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.
</pre><p>This method is usefull in finding the 'next' token in a string, for example: </p>
<pre></pre><pre>Returns a pointer to the first token in 'input'
        const char* token = stripSpace(input)</pre><pre>Returns a pointer to the second token in 'input'
        token = stripSpace(stripNotSpace(token))</pre><pre></pre> 
</div>
</div>
<a class="anchor" id="ac14e61c7a26d37010bdfe93ade5b59ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a pointer to the FIRST non-whitespace character in the the specified null-terminated string. NOTES: </p>
<pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.</pre> 
</div>
</div>
<a class="anchor" id="a7480520348029f1b992f6fbef338010d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripTrailingChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as stripTrailingSpaces(), except the specified character set is used to identify the last "non-whitespace" character.</p>
<p>NOTES: </p>
<pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.</pre> 
</div>
</div>
<a class="anchor" id="a08a9a7fd5c7962fc037dd8ab9fd51355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripTrailingSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a pointer to the LAST non-whitespace character in the the specified null-terminated string.</p>
<p>NOTES: </p>
<pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_cpl.html">Cpl</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_text.html">Text</a></li>
    <li class="footer">Generated on Thu Mar 5 2015 07:47:29 for Colony.Core by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
